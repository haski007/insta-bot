/*
instagrapi-rest

RESTful API Service for instagrapi

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package instapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// MediaApiService MediaApi service
type MediaApiService service

type ApiMediaArchiveMediaArchivePostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
	revert     *bool
}

func (r ApiMediaArchiveMediaArchivePostRequest) Sessionid(sessionid string) ApiMediaArchiveMediaArchivePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaArchiveMediaArchivePostRequest) MediaId(mediaId string) ApiMediaArchiveMediaArchivePostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaArchiveMediaArchivePostRequest) Revert(revert bool) ApiMediaArchiveMediaArchivePostRequest {
	r.revert = &revert
	return r
}

func (r ApiMediaArchiveMediaArchivePostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MediaArchiveMediaArchivePostExecute(r)
}

/*
MediaArchiveMediaArchivePost Media Archive

# Archive a media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaArchiveMediaArchivePostRequest
*/
func (a *MediaApiService) MediaArchiveMediaArchivePost(ctx context.Context) ApiMediaArchiveMediaArchivePostRequest {
	return ApiMediaArchiveMediaArchivePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *MediaApiService) MediaArchiveMediaArchivePostExecute(r ApiMediaArchiveMediaArchivePostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaArchiveMediaArchivePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	if r.revert != nil {
		localVarFormParams.Add("revert", parameterToString(*r.revert, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaDeleteMediaDeletePostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
}

func (r ApiMediaDeleteMediaDeletePostRequest) Sessionid(sessionid string) ApiMediaDeleteMediaDeletePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaDeleteMediaDeletePostRequest) MediaId(mediaId string) ApiMediaDeleteMediaDeletePostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaDeleteMediaDeletePostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MediaDeleteMediaDeletePostExecute(r)
}

/*
MediaDeleteMediaDeletePost Media Delete

# Delete media by Media ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaDeleteMediaDeletePostRequest
*/
func (a *MediaApiService) MediaDeleteMediaDeletePost(ctx context.Context) ApiMediaDeleteMediaDeletePostRequest {
	return ApiMediaDeleteMediaDeletePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *MediaApiService) MediaDeleteMediaDeletePostExecute(r ApiMediaDeleteMediaDeletePostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaDeleteMediaDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaEditMediaEditPostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
	caption    *string
	title      *string
	usertags   *[]Usertag
	location   *Location
}

func (r ApiMediaEditMediaEditPostRequest) Sessionid(sessionid string) ApiMediaEditMediaEditPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaEditMediaEditPostRequest) MediaId(mediaId string) ApiMediaEditMediaEditPostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaEditMediaEditPostRequest) Caption(caption string) ApiMediaEditMediaEditPostRequest {
	r.caption = &caption
	return r
}

func (r ApiMediaEditMediaEditPostRequest) Title(title string) ApiMediaEditMediaEditPostRequest {
	r.title = &title
	return r
}

func (r ApiMediaEditMediaEditPostRequest) Usertags(usertags []Usertag) ApiMediaEditMediaEditPostRequest {
	r.usertags = &usertags
	return r
}

func (r ApiMediaEditMediaEditPostRequest) Location(location Location) ApiMediaEditMediaEditPostRequest {
	r.location = &location
	return r
}

func (r ApiMediaEditMediaEditPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MediaEditMediaEditPostExecute(r)
}

/*
MediaEditMediaEditPost Media Edit

# Edit caption for media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaEditMediaEditPostRequest
*/
func (a *MediaApiService) MediaEditMediaEditPost(ctx context.Context) ApiMediaEditMediaEditPostRequest {
	return ApiMediaEditMediaEditPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MediaApiService) MediaEditMediaEditPostExecute(r ApiMediaEditMediaEditPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaEditMediaEditPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}
	if r.caption == nil {
		return localVarReturnValue, nil, reportError("caption is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	localVarFormParams.Add("caption", parameterToString(*r.caption, ""))
	if r.title != nil {
		localVarFormParams.Add("title", parameterToString(*r.title, ""))
	}
	if r.usertags != nil {
		localVarFormParams.Add("usertags", parameterToString(*r.usertags, "csv"))
	}
	if r.location != nil {
		paramJson, err := parameterToJson(*r.location)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("location", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaIdMediaIdGetRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	mediaPk    *int32
}

func (r ApiMediaIdMediaIdGetRequest) MediaPk(mediaPk int32) ApiMediaIdMediaIdGetRequest {
	r.mediaPk = &mediaPk
	return r
}

func (r ApiMediaIdMediaIdGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.MediaIdMediaIdGetExecute(r)
}

/*
MediaIdMediaIdGet Media Id

# Get full media id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaIdMediaIdGetRequest
*/
func (a *MediaApiService) MediaIdMediaIdGet(ctx context.Context) ApiMediaIdMediaIdGetRequest {
	return ApiMediaIdMediaIdGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *MediaApiService) MediaIdMediaIdGetExecute(r ApiMediaIdMediaIdGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaIdMediaIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaPk == nil {
		return localVarReturnValue, nil, reportError("mediaPk is required and must be specified")
	}

	localVarQueryParams.Add("media_pk", parameterToString(*r.mediaPk, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaInfoMediaInfoPostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	pk         *int
	useCache   *bool
}

func (r ApiMediaInfoMediaInfoPostRequest) Sessionid(sessionid string) ApiMediaInfoMediaInfoPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaInfoMediaInfoPostRequest) Pk(pk int) ApiMediaInfoMediaInfoPostRequest {
	r.pk = &pk
	return r
}

func (r ApiMediaInfoMediaInfoPostRequest) UseCache(useCache bool) ApiMediaInfoMediaInfoPostRequest {
	r.useCache = &useCache
	return r
}

func (r ApiMediaInfoMediaInfoPostRequest) Execute() (*Media, *http.Response, error) {
	return r.ApiService.MediaInfoMediaInfoPostExecute(r)
}

/*
MediaInfoMediaInfoPost Media Info

# Get media info by pk

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaInfoMediaInfoPostRequest
*/
func (a *MediaApiService) MediaInfoMediaInfoPost(ctx context.Context) ApiMediaInfoMediaInfoPostRequest {
	return ApiMediaInfoMediaInfoPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Media
func (a *MediaApiService) MediaInfoMediaInfoPostExecute(r ApiMediaInfoMediaInfoPostRequest) (*Media, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Media
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaInfoMediaInfoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.pk == nil {
		return localVarReturnValue, nil, reportError("pk is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("pk", parameterToString(*r.pk, ""))
	if r.useCache != nil {
		localVarFormParams.Add("use_cache", parameterToString(*r.useCache, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaLikeMediaLikePostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
	revert     *bool
}

func (r ApiMediaLikeMediaLikePostRequest) Sessionid(sessionid string) ApiMediaLikeMediaLikePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaLikeMediaLikePostRequest) MediaId(mediaId string) ApiMediaLikeMediaLikePostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaLikeMediaLikePostRequest) Revert(revert bool) ApiMediaLikeMediaLikePostRequest {
	r.revert = &revert
	return r
}

func (r ApiMediaLikeMediaLikePostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MediaLikeMediaLikePostExecute(r)
}

/*
MediaLikeMediaLikePost Media Like

# Like a media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaLikeMediaLikePostRequest
*/
func (a *MediaApiService) MediaLikeMediaLikePost(ctx context.Context) ApiMediaLikeMediaLikePostRequest {
	return ApiMediaLikeMediaLikePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *MediaApiService) MediaLikeMediaLikePostExecute(r ApiMediaLikeMediaLikePostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaLikeMediaLikePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/like"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	if r.revert != nil {
		localVarFormParams.Add("revert", parameterToString(*r.revert, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaLikersMediaLikersPostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
}

func (r ApiMediaLikersMediaLikersPostRequest) Sessionid(sessionid string) ApiMediaLikersMediaLikersPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaLikersMediaLikersPostRequest) MediaId(mediaId string) ApiMediaLikersMediaLikersPostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaLikersMediaLikersPostRequest) Execute() ([]UserShort, *http.Response, error) {
	return r.ApiService.MediaLikersMediaLikersPostExecute(r)
}

/*
MediaLikersMediaLikersPost Media Likers

# Get user's likers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaLikersMediaLikersPostRequest
*/
func (a *MediaApiService) MediaLikersMediaLikersPost(ctx context.Context) ApiMediaLikersMediaLikersPostRequest {
	return ApiMediaLikersMediaLikersPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []UserShort
func (a *MediaApiService) MediaLikersMediaLikersPostExecute(r ApiMediaLikersMediaLikersPostRequest) ([]UserShort, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserShort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaLikersMediaLikersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/likers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaOembedMediaOembedPostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	url        *string
}

func (r ApiMediaOembedMediaOembedPostRequest) Sessionid(sessionid string) ApiMediaOembedMediaOembedPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaOembedMediaOembedPostRequest) Url(url string) ApiMediaOembedMediaOembedPostRequest {
	r.url = &url
	return r
}

func (r ApiMediaOembedMediaOembedPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MediaOembedMediaOembedPostExecute(r)
}

/*
MediaOembedMediaOembedPost Media Oembed

# Return info about media and user from post URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaOembedMediaOembedPostRequest
*/
func (a *MediaApiService) MediaOembedMediaOembedPost(ctx context.Context) ApiMediaOembedMediaOembedPostRequest {
	return ApiMediaOembedMediaOembedPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MediaApiService) MediaOembedMediaOembedPostExecute(r ApiMediaOembedMediaOembedPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaOembedMediaOembedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/oembed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("url", parameterToString(*r.url, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaPkFromCodeMediaPkFromCodeGetRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	code       *string
}

func (r ApiMediaPkFromCodeMediaPkFromCodeGetRequest) Code(code string) ApiMediaPkFromCodeMediaPkFromCodeGetRequest {
	r.code = &code
	return r
}

func (r ApiMediaPkFromCodeMediaPkFromCodeGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.MediaPkFromCodeMediaPkFromCodeGetExecute(r)
}

/*
MediaPkFromCodeMediaPkFromCodeGet Media Pk From Code

# Get media pk from code

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaPkFromCodeMediaPkFromCodeGetRequest
*/
func (a *MediaApiService) MediaPkFromCodeMediaPkFromCodeGet(ctx context.Context) ApiMediaPkFromCodeMediaPkFromCodeGetRequest {
	return ApiMediaPkFromCodeMediaPkFromCodeGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *MediaApiService) MediaPkFromCodeMediaPkFromCodeGetExecute(r ApiMediaPkFromCodeMediaPkFromCodeGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaPkFromCodeMediaPkFromCodeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/pk_from_code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}

	localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaPkFromUrlMediaPkFromUrlGetRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	url        *string
}

func (r ApiMediaPkFromUrlMediaPkFromUrlGetRequest) Url(url string) ApiMediaPkFromUrlMediaPkFromUrlGetRequest {
	r.url = &url
	return r
}

func (r ApiMediaPkFromUrlMediaPkFromUrlGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.MediaPkFromUrlMediaPkFromUrlGetExecute(r)
}

/*
MediaPkFromUrlMediaPkFromUrlGet Media Pk From Url

# Get Media PK from URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaPkFromUrlMediaPkFromUrlGetRequest
*/
func (a *MediaApiService) MediaPkFromUrlMediaPkFromUrlGet(ctx context.Context) ApiMediaPkFromUrlMediaPkFromUrlGetRequest {
	return ApiMediaPkFromUrlMediaPkFromUrlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *MediaApiService) MediaPkFromUrlMediaPkFromUrlGetExecute(r ApiMediaPkFromUrlMediaPkFromUrlGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaPkFromUrlMediaPkFromUrlGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/pk_from_url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	localVarQueryParams.Add("url", parameterToString(*r.url, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaPkMediaPkGetRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	mediaId    *string
}

func (r ApiMediaPkMediaPkGetRequest) MediaId(mediaId string) ApiMediaPkMediaPkGetRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaPkMediaPkGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.MediaPkMediaPkGetExecute(r)
}

/*
MediaPkMediaPkGet Media Pk

# Get short media id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaPkMediaPkGetRequest
*/
func (a *MediaApiService) MediaPkMediaPkGet(ctx context.Context) ApiMediaPkMediaPkGetRequest {
	return ApiMediaPkMediaPkGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *MediaApiService) MediaPkMediaPkGetExecute(r ApiMediaPkMediaPkGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaPkMediaPkGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/pk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	localVarQueryParams.Add("media_id", parameterToString(*r.mediaId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaSeenMediaSeenPostRequest struct {
	ctx             context.Context
	ApiService      *MediaApiService
	sessionid       *string
	mediaIds        *[]string
	skippedMediaIds *[]string
}

func (r ApiMediaSeenMediaSeenPostRequest) Sessionid(sessionid string) ApiMediaSeenMediaSeenPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaSeenMediaSeenPostRequest) MediaIds(mediaIds []string) ApiMediaSeenMediaSeenPostRequest {
	r.mediaIds = &mediaIds
	return r
}

func (r ApiMediaSeenMediaSeenPostRequest) SkippedMediaIds(skippedMediaIds []string) ApiMediaSeenMediaSeenPostRequest {
	r.skippedMediaIds = &skippedMediaIds
	return r
}

func (r ApiMediaSeenMediaSeenPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MediaSeenMediaSeenPostExecute(r)
}

/*
MediaSeenMediaSeenPost Media Seen

# Mark a media as seen

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaSeenMediaSeenPostRequest
*/
func (a *MediaApiService) MediaSeenMediaSeenPost(ctx context.Context) ApiMediaSeenMediaSeenPostRequest {
	return ApiMediaSeenMediaSeenPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *MediaApiService) MediaSeenMediaSeenPostExecute(r ApiMediaSeenMediaSeenPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaSeenMediaSeenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/seen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaIds == nil {
		return localVarReturnValue, nil, reportError("mediaIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_ids", parameterToString(*r.mediaIds, "csv"))
	if r.skippedMediaIds != nil {
		localVarFormParams.Add("skipped_media_ids", parameterToString(*r.skippedMediaIds, "csv"))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUnarchiveMediaUnarchivePostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
}

func (r ApiMediaUnarchiveMediaUnarchivePostRequest) Sessionid(sessionid string) ApiMediaUnarchiveMediaUnarchivePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaUnarchiveMediaUnarchivePostRequest) MediaId(mediaId string) ApiMediaUnarchiveMediaUnarchivePostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaUnarchiveMediaUnarchivePostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MediaUnarchiveMediaUnarchivePostExecute(r)
}

/*
MediaUnarchiveMediaUnarchivePost Media Unarchive

# Unarchive a media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaUnarchiveMediaUnarchivePostRequest
*/
func (a *MediaApiService) MediaUnarchiveMediaUnarchivePost(ctx context.Context) ApiMediaUnarchiveMediaUnarchivePostRequest {
	return ApiMediaUnarchiveMediaUnarchivePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *MediaApiService) MediaUnarchiveMediaUnarchivePostExecute(r ApiMediaUnarchiveMediaUnarchivePostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUnarchiveMediaUnarchivePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUnlikeMediaUnlikePostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaId    *string
}

func (r ApiMediaUnlikeMediaUnlikePostRequest) Sessionid(sessionid string) ApiMediaUnlikeMediaUnlikePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaUnlikeMediaUnlikePostRequest) MediaId(mediaId string) ApiMediaUnlikeMediaUnlikePostRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiMediaUnlikeMediaUnlikePostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MediaUnlikeMediaUnlikePostExecute(r)
}

/*
MediaUnlikeMediaUnlikePost Media Unlike

# Unlike a media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaUnlikeMediaUnlikePostRequest
*/
func (a *MediaApiService) MediaUnlikeMediaUnlikePost(ctx context.Context) ApiMediaUnlikeMediaUnlikePostRequest {
	return ApiMediaUnlikeMediaUnlikePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return bool
func (a *MediaApiService) MediaUnlikeMediaUnlikePostExecute(r ApiMediaUnlikeMediaUnlikePostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUnlikeMediaUnlikePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/unlike"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_id", parameterToString(*r.mediaId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUserMediaUserPostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	mediaPk    *int32
}

func (r ApiMediaUserMediaUserPostRequest) Sessionid(sessionid string) ApiMediaUserMediaUserPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMediaUserMediaUserPostRequest) MediaPk(mediaPk int32) ApiMediaUserMediaUserPostRequest {
	r.mediaPk = &mediaPk
	return r
}

func (r ApiMediaUserMediaUserPostRequest) Execute() (*UserShort, *http.Response, error) {
	return r.ApiService.MediaUserMediaUserPostExecute(r)
}

/*
MediaUserMediaUserPost Media User

# Get author of the media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMediaUserMediaUserPostRequest
*/
func (a *MediaApiService) MediaUserMediaUserPost(ctx context.Context) ApiMediaUserMediaUserPostRequest {
	return ApiMediaUserMediaUserPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserShort
func (a *MediaApiService) MediaUserMediaUserPostExecute(r ApiMediaUserMediaUserPostRequest) (*UserShort, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserShort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUserMediaUserPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.mediaPk == nil {
		return localVarReturnValue, nil, reportError("mediaPk is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("media_pk", parameterToString(*r.mediaPk, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserMediasMediaUserMediasPostRequest struct {
	ctx        context.Context
	ApiService *MediaApiService
	sessionid  *string
	userId     *int32
	amount     *int32
}

func (r ApiUserMediasMediaUserMediasPostRequest) Sessionid(sessionid string) ApiUserMediasMediaUserMediasPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserMediasMediaUserMediasPostRequest) UserId(userId int32) ApiUserMediasMediaUserMediasPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserMediasMediaUserMediasPostRequest) Amount(amount int32) ApiUserMediasMediaUserMediasPostRequest {
	r.amount = &amount
	return r
}

func (r ApiUserMediasMediaUserMediasPostRequest) Execute() ([]Media, *http.Response, error) {
	return r.ApiService.UserMediasMediaUserMediasPostExecute(r)
}

/*
UserMediasMediaUserMediasPost User Medias

# Get a user's media

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserMediasMediaUserMediasPostRequest
*/
func (a *MediaApiService) UserMediasMediaUserMediasPost(ctx context.Context) ApiUserMediasMediaUserMediasPostRequest {
	return ApiUserMediasMediaUserMediasPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Media
func (a *MediaApiService) UserMediasMediaUserMediasPostExecute(r ApiUserMediasMediaUserMediasPostRequest) ([]Media, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Media
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.UserMediasMediaUserMediasPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/media/user_medias"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.amount != nil {
		localVarFormParams.Add("amount", parameterToString(*r.amount, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
