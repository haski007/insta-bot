/*
instagrapi-rest

RESTful API Service for instagrapi

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package instapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// UserApiService UserApi service
type UserApiService service

type ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
	revert *bool
}

func (r ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest) Sessionid(sessionid string) ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest) UserId(userId int32) ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest {
	r.userId = &userId
	return r
}

func (r ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest) Revert(revert bool) ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest {
	r.revert = &revert
	return r
}

func (r ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MutePostsFromFollowUserMutePostsFromFollowPostExecute(r)
}

/*
MutePostsFromFollowUserMutePostsFromFollowPost Mute Posts From Follow

Mute posts from following user
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest
*/
func (a *UserApiService) MutePostsFromFollowUserMutePostsFromFollowPost(ctx context.Context) ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest {
	return ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) MutePostsFromFollowUserMutePostsFromFollowPostExecute(r ApiMutePostsFromFollowUserMutePostsFromFollowPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.MutePostsFromFollowUserMutePostsFromFollowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/mute_posts_from_follow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.revert != nil {
		localVarFormParams.Add("revert", parameterToString(*r.revert, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
	revert *bool
}

func (r ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest) Sessionid(sessionid string) ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest) UserId(userId int32) ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest {
	r.userId = &userId
	return r
}

func (r ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest) Revert(revert bool) ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest {
	r.revert = &revert
	return r
}

func (r ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.MuteStoriesFromFollowUserMuteStoriesFromFollowPostExecute(r)
}

/*
MuteStoriesFromFollowUserMuteStoriesFromFollowPost Mute Stories From Follow

Mute stories from following user
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest
*/
func (a *UserApiService) MuteStoriesFromFollowUserMuteStoriesFromFollowPost(ctx context.Context) ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest {
	return ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) MuteStoriesFromFollowUserMuteStoriesFromFollowPostExecute(r ApiMuteStoriesFromFollowUserMuteStoriesFromFollowPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.MuteStoriesFromFollowUserMuteStoriesFromFollowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/mute_stories_from_follow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.revert != nil {
		localVarFormParams.Add("revert", parameterToString(*r.revert, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
}

func (r ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest) Sessionid(sessionid string) ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest) UserId(userId int32) ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.UnmutePostsFromFollowUserUnmutePostsFromFollowPostExecute(r)
}

/*
UnmutePostsFromFollowUserUnmutePostsFromFollowPost Unmute Posts From Follow

Unmute posts from following user
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest
*/
func (a *UserApiService) UnmutePostsFromFollowUserUnmutePostsFromFollowPost(ctx context.Context) ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest {
	return ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) UnmutePostsFromFollowUserUnmutePostsFromFollowPostExecute(r ApiUnmutePostsFromFollowUserUnmutePostsFromFollowPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UnmutePostsFromFollowUserUnmutePostsFromFollowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/unmute_posts_from_follow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
}

func (r ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest) Sessionid(sessionid string) ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest) UserId(userId int32) ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.UnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostExecute(r)
}

/*
UnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPost Unmute Stories From Follow

Unmute stories from following user
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest
*/
func (a *UserApiService) UnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPost(ctx context.Context) ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest {
	return ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) UnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostExecute(r ApiUnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UnmuteStoriesFromFollowUserUnmuteStoriesFromFollowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/unmute_stories_from_follow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowUserFollowPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
}

func (r ApiUserFollowUserFollowPostRequest) Sessionid(sessionid string) ApiUserFollowUserFollowPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserFollowUserFollowPostRequest) UserId(userId int32) ApiUserFollowUserFollowPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserFollowUserFollowPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.UserFollowUserFollowPostExecute(r)
}

/*
UserFollowUserFollowPost User Follow

Follow a user
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserFollowUserFollowPostRequest
*/
func (a *UserApiService) UserFollowUserFollowPost(ctx context.Context) ApiUserFollowUserFollowPostRequest {
	return ApiUserFollowUserFollowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) UserFollowUserFollowPostExecute(r ApiUserFollowUserFollowPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserFollowUserFollowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/follow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowersUserFollowersPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *string
	useCache *bool
	amount *int32
}

func (r ApiUserFollowersUserFollowersPostRequest) Sessionid(sessionid string) ApiUserFollowersUserFollowersPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserFollowersUserFollowersPostRequest) UserId(userId string) ApiUserFollowersUserFollowersPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserFollowersUserFollowersPostRequest) UseCache(useCache bool) ApiUserFollowersUserFollowersPostRequest {
	r.useCache = &useCache
	return r
}

func (r ApiUserFollowersUserFollowersPostRequest) Amount(amount int32) ApiUserFollowersUserFollowersPostRequest {
	r.amount = &amount
	return r
}

func (r ApiUserFollowersUserFollowersPostRequest) Execute() (*map[string]UserShort, *http.Response, error) {
	return r.ApiService.UserFollowersUserFollowersPostExecute(r)
}

/*
UserFollowersUserFollowersPost User Followers

Get user's followers
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserFollowersUserFollowersPostRequest
*/
func (a *UserApiService) UserFollowersUserFollowersPost(ctx context.Context) ApiUserFollowersUserFollowersPostRequest {
	return ApiUserFollowersUserFollowersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]UserShort
func (a *UserApiService) UserFollowersUserFollowersPostExecute(r ApiUserFollowersUserFollowersPostRequest) (*map[string]UserShort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]UserShort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserFollowersUserFollowersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/followers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.useCache != nil {
		localVarFormParams.Add("use_cache", parameterToString(*r.useCache, ""))
	}
	if r.amount != nil {
		localVarFormParams.Add("amount", parameterToString(*r.amount, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowingUserFollowingPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *string
	useCache *bool
	amount *int32
}

func (r ApiUserFollowingUserFollowingPostRequest) Sessionid(sessionid string) ApiUserFollowingUserFollowingPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserFollowingUserFollowingPostRequest) UserId(userId string) ApiUserFollowingUserFollowingPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserFollowingUserFollowingPostRequest) UseCache(useCache bool) ApiUserFollowingUserFollowingPostRequest {
	r.useCache = &useCache
	return r
}

func (r ApiUserFollowingUserFollowingPostRequest) Amount(amount int32) ApiUserFollowingUserFollowingPostRequest {
	r.amount = &amount
	return r
}

func (r ApiUserFollowingUserFollowingPostRequest) Execute() (*map[string]UserShort, *http.Response, error) {
	return r.ApiService.UserFollowingUserFollowingPostExecute(r)
}

/*
UserFollowingUserFollowingPost User Following

Get user's followers information
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserFollowingUserFollowingPostRequest
*/
func (a *UserApiService) UserFollowingUserFollowingPost(ctx context.Context) ApiUserFollowingUserFollowingPostRequest {
	return ApiUserFollowingUserFollowingPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]UserShort
func (a *UserApiService) UserFollowingUserFollowingPostExecute(r ApiUserFollowingUserFollowingPostRequest) (*map[string]UserShort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]UserShort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserFollowingUserFollowingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.useCache != nil {
		localVarFormParams.Add("use_cache", parameterToString(*r.useCache, ""))
	}
	if r.amount != nil {
		localVarFormParams.Add("amount", parameterToString(*r.amount, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserIdFromUsernameUserIdFromUsernamePostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	username *string
}

func (r ApiUserIdFromUsernameUserIdFromUsernamePostRequest) Sessionid(sessionid string) ApiUserIdFromUsernameUserIdFromUsernamePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserIdFromUsernameUserIdFromUsernamePostRequest) Username(username string) ApiUserIdFromUsernameUserIdFromUsernamePostRequest {
	r.username = &username
	return r
}

func (r ApiUserIdFromUsernameUserIdFromUsernamePostRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.UserIdFromUsernameUserIdFromUsernamePostExecute(r)
}

/*
UserIdFromUsernameUserIdFromUsernamePost User Id From Username

Get user id from username
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserIdFromUsernameUserIdFromUsernamePostRequest
*/
func (a *UserApiService) UserIdFromUsernameUserIdFromUsernamePost(ctx context.Context) ApiUserIdFromUsernameUserIdFromUsernamePostRequest {
	return ApiUserIdFromUsernameUserIdFromUsernamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *UserApiService) UserIdFromUsernameUserIdFromUsernamePostExecute(r ApiUserIdFromUsernameUserIdFromUsernamePostRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserIdFromUsernameUserIdFromUsernamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/id_from_username"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("username", parameterToString(*r.username, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserInfoByUsernameUserInfoByUsernamePostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	username *string
	useCache *bool
}

func (r ApiUserInfoByUsernameUserInfoByUsernamePostRequest) Sessionid(sessionid string) ApiUserInfoByUsernameUserInfoByUsernamePostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserInfoByUsernameUserInfoByUsernamePostRequest) Username(username string) ApiUserInfoByUsernameUserInfoByUsernamePostRequest {
	r.username = &username
	return r
}

func (r ApiUserInfoByUsernameUserInfoByUsernamePostRequest) UseCache(useCache bool) ApiUserInfoByUsernameUserInfoByUsernamePostRequest {
	r.useCache = &useCache
	return r
}

func (r ApiUserInfoByUsernameUserInfoByUsernamePostRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UserInfoByUsernameUserInfoByUsernamePostExecute(r)
}

/*
UserInfoByUsernameUserInfoByUsernamePost User Info By Username

Get user object from username
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserInfoByUsernameUserInfoByUsernamePostRequest
*/
func (a *UserApiService) UserInfoByUsernameUserInfoByUsernamePost(ctx context.Context) ApiUserInfoByUsernameUserInfoByUsernamePostRequest {
	return ApiUserInfoByUsernameUserInfoByUsernamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UserApiService) UserInfoByUsernameUserInfoByUsernamePostExecute(r ApiUserInfoByUsernameUserInfoByUsernamePostRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserInfoByUsernameUserInfoByUsernamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/info_by_username"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("username", parameterToString(*r.username, ""))
	if r.useCache != nil {
		localVarFormParams.Add("use_cache", parameterToString(*r.useCache, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserInfoUserInfoPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *string
	useCache *bool
}

func (r ApiUserInfoUserInfoPostRequest) Sessionid(sessionid string) ApiUserInfoUserInfoPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserInfoUserInfoPostRequest) UserId(userId string) ApiUserInfoUserInfoPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserInfoUserInfoPostRequest) UseCache(useCache bool) ApiUserInfoUserInfoPostRequest {
	r.useCache = &useCache
	return r
}

func (r ApiUserInfoUserInfoPostRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UserInfoUserInfoPostExecute(r)
}

/*
UserInfoUserInfoPost User Info

Get user object from user id
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserInfoUserInfoPostRequest
*/
func (a *UserApiService) UserInfoUserInfoPost(ctx context.Context) ApiUserInfoUserInfoPostRequest {
	return ApiUserInfoUserInfoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UserApiService) UserInfoUserInfoPostExecute(r ApiUserInfoUserInfoPostRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserInfoUserInfoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.useCache != nil {
		localVarFormParams.Add("use_cache", parameterToString(*r.useCache, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRemoveFollowerUserRemoveFollowerPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
}

func (r ApiUserRemoveFollowerUserRemoveFollowerPostRequest) Sessionid(sessionid string) ApiUserRemoveFollowerUserRemoveFollowerPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserRemoveFollowerUserRemoveFollowerPostRequest) UserId(userId int32) ApiUserRemoveFollowerUserRemoveFollowerPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserRemoveFollowerUserRemoveFollowerPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.UserRemoveFollowerUserRemoveFollowerPostExecute(r)
}

/*
UserRemoveFollowerUserRemoveFollowerPost User Remove Follower

Remove a follower
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserRemoveFollowerUserRemoveFollowerPostRequest
*/
func (a *UserApiService) UserRemoveFollowerUserRemoveFollowerPost(ctx context.Context) ApiUserRemoveFollowerUserRemoveFollowerPostRequest {
	return ApiUserRemoveFollowerUserRemoveFollowerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) UserRemoveFollowerUserRemoveFollowerPostExecute(r ApiUserRemoveFollowerUserRemoveFollowerPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserRemoveFollowerUserRemoveFollowerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/remove_follower"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUnfollowUserUnfollowPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
}

func (r ApiUserUnfollowUserUnfollowPostRequest) Sessionid(sessionid string) ApiUserUnfollowUserUnfollowPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUserUnfollowUserUnfollowPostRequest) UserId(userId int32) ApiUserUnfollowUserUnfollowPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUserUnfollowUserUnfollowPostRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.UserUnfollowUserUnfollowPostExecute(r)
}

/*
UserUnfollowUserUnfollowPost User Unfollow

Unfollow a user
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserUnfollowUserUnfollowPostRequest
*/
func (a *UserApiService) UserUnfollowUserUnfollowPost(ctx context.Context) ApiUserUnfollowUserUnfollowPostRequest {
	return ApiUserUnfollowUserUnfollowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *UserApiService) UserUnfollowUserUnfollowPostExecute(r ApiUserUnfollowUserUnfollowPostRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserUnfollowUserUnfollowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/unfollow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsernameFromUserIdUserUsernameFromIdPostRequest struct {
	ctx context.Context
	ApiService *UserApiService
	sessionid *string
	userId *int32
}

func (r ApiUsernameFromUserIdUserUsernameFromIdPostRequest) Sessionid(sessionid string) ApiUsernameFromUserIdUserUsernameFromIdPostRequest {
	r.sessionid = &sessionid
	return r
}

func (r ApiUsernameFromUserIdUserUsernameFromIdPostRequest) UserId(userId int32) ApiUsernameFromUserIdUserUsernameFromIdPostRequest {
	r.userId = &userId
	return r
}

func (r ApiUsernameFromUserIdUserUsernameFromIdPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UsernameFromUserIdUserUsernameFromIdPostExecute(r)
}

/*
UsernameFromUserIdUserUsernameFromIdPost Username From User Id

Get username from user id
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsernameFromUserIdUserUsernameFromIdPostRequest
*/
func (a *UserApiService) UsernameFromUserIdUserUsernameFromIdPost(ctx context.Context) ApiUsernameFromUserIdUserUsernameFromIdPostRequest {
	return ApiUsernameFromUserIdUserUsernameFromIdPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *UserApiService) UsernameFromUserIdUserUsernameFromIdPostExecute(r ApiUsernameFromUserIdUserUsernameFromIdPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UsernameFromUserIdUserUsernameFromIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/username_from_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionid == nil {
		return localVarReturnValue, nil, reportError("sessionid is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("sessionid", parameterToString(*r.sessionid, ""))
	localVarFormParams.Add("user_id", parameterToString(*r.userId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
